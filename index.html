<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Spectrum Analyzer</title>
    <style>
        :root { --accent: #00ffcc; --sub-accent: #ff00ff; }
        body { background: #1a1a1a; color: #fff; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; overflow: hidden; touch-action: none; }
        .header { margin: 10px; text-align: center; }
        h1 { font-size: 1.4rem; margin: 5px 0; color: var(--accent); }
        #modeLabel { color: #fff; font-weight: bold; font-size: 1.0rem; background: #444; padding: 2px 12px; border-radius: 20px; border: 1px solid var(--accent); }
        
        .canvas-container { position: relative; width: 95vw; height: 50vh; }
        canvas { 
            width: 100%; height: 100%; background: #000; 
            border: 2px solid #333; border-radius: 8px; cursor: crosshair;
            touch-action: none;
        }
        .freq-label { position: absolute; bottom: 5px; font-size: 0.8rem; color: #aaa; background: rgba(0,0,0,0.6); padding: 2px 5px; pointer-events: none; }
        #minFreqLabel { left: 10px; }
        #maxFreqLabel { right: 10px; }

        .controls { width: 92%; background: #2a2a2a; padding: 12px; border-radius: 12px; margin-top: 8px; display: grid; grid-template-columns: 1fr 1.5fr; gap: 10px; }
        .btn-group { display: flex; flex-direction: column; gap: 8px; }
        button { padding: 10px 5px; font-size: 0.85rem; font-weight: bold; background: var(--accent); border: none; border-radius: 8px; cursor: pointer; color: #000; }
        button.active { background: #ff4444; color: #fff; }
        #modeBtn { background: var(--sub-accent); color: #fff; }

        .slider-area { display: flex; flex-direction: column; gap: 8px; background: #333; padding: 8px; border-radius: 8px; }
        .slider-box { display: flex; flex-direction: column; gap: 2px; }
        input[type=range] { width: 100%; cursor: pointer; }
        .help-text { font-size: 0.7rem; color: #aaa; grid-column: span 2; text-align: center; margin-top: 5px; line-height: 1.4; }
        .stat-label { font-size: 0.75rem; color: var(--accent); }
    </style>
</head>
<body>

    <div class="header">
        <h1>Spectrum Analyzer</h1>
        <span id="modeLabel">周波数表示 (FFT)</span>
    </div>

    <div class="canvas-container">
        <canvas id="visualizer"></canvas>
        <span id="minFreqLabel" class="freq-label">0 Hz</span>
        <span id="maxFreqLabel" class="freq-label">500 Hz</span>
    </div>

    <div class="controls">
        <div class="btn-group">
            <button id="toggleBtn">開始</button>
            <button id="modeBtn">表示切替</button>
        </div>
        
        <div class="slider-area">
            <div class="slider-box" id="spectrumSliderBox">
                <span class="stat-label">表示帯域幅 (Span): <span id="spanVal">500</span>Hz</span>
                <input type="range" id="spanSlider" min="10" max="2000" step="10" value="500">
            </div>
            <div class="slider-box" id="oscilloSliderBox" style="display:none;">
                <span class="stat-label" style="color:var(--sub-accent);">表示時間: <span id="timeVal">20</span>ms</span>
                <input type="range" id="timeSlider" min="1" max="500" step="1" value="20">
            </div>
            <div id="verticalScaleText" style="font-size:0.7rem; color:#fff;">縦軸拡大率: 1.0x</div>
        </div>

        <div class="help-text">
            1本指: 左右移動 (FFTのみ) / 2本指: 感度調整
        </div>
    </div>

<script>
let audioCtx, analyser, dataArray, animationId;
let minFreq = 0, spanFreq = 500, timeMs = 20, vScale = 1.0;
let isOscilloscope = false;

const canvas = document.getElementById('visualizer');
const ctx = canvas.getContext('2d');
const toggleBtn = document.getElementById('toggleBtn');
const modeBtn = document.getElementById('modeBtn');
const spanSlider = document.getElementById('spanSlider');
const timeSlider = document.getElementById('timeSlider');
const vScaleText = document.getElementById('verticalScaleText');
const minLabel = document.getElementById('minFreqLabel');
const maxLabel = document.getElementById('maxFreqLabel');

function resize() {
    canvas.width = canvas.clientWidth * window.devicePixelRatio;
    canvas.height = canvas.clientHeight * window.devicePixelRatio;
}
window.addEventListener('resize', resize);
resize();

// タッチ操作
let activePointers = new Map();
let lastX = 0, lastY = 0;
canvas.addEventListener('pointerdown', (e) => { canvas.setPointerCapture(e.pointerId); activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY }); updatePivot(); });
canvas.addEventListener('pointermove', (e) => {
    if (!activePointers.has(e.pointerId) || !audioCtx) return;
    activePointers.set(e.pointerId, { x: e.clientX, y: e.clientY });
    if (activePointers.size === 1 && !isOscilloscope) {
        minFreq -= ((e.clientX - lastX) * (spanFreq / canvas.clientWidth));
        minFreq = Math.max(0, minFreq);
    } else if (activePointers.size === 2) {
        vScale *= Math.pow(1.005, lastY - getAverageY());
        vScale = Math.max(0.1, Math.min(20, vScale));
        vScaleText.innerText = `縦軸拡大率: ${vScale.toFixed(1)}x`;
    }
    updatePivot();
});
function updatePivot() { if (activePointers.size === 1) { const p = activePointers.values().next().value; lastX = p.x; lastY = p.y; } else if (activePointers.size === 2) lastY = getAverageY(); }
function getAverageY() { let sum = 0; activePointers.forEach(p => sum += p.y); return sum / activePointers.size; }
canvas.addEventListener('pointerup', (e) => { activePointers.delete(e.pointerId); if (activePointers.size > 0) updatePivot(); });

async function init() {
    const AudioContext = window.AudioContext || window.webkitAudioContext;
    audioCtx = new AudioContext();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    // 最大級のバッファ（32768）を確保し、長時間表示と高精度FFTを両立
    analyser.fftSize = 32768; 
    source.connect(analyser);
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    draw();
}

function draw() {
    animationId = requestAnimationFrame(draw);
    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);
    
    if (!isOscilloscope) {
        analyser.getByteFrequencyData(dataArray);
        drawSpectrum();
    } else {
        analyser.getByteTimeDomainData(dataArray);
        drawOscilloscope();
    }
}

function drawSpectrum() {
    spanFreq = parseInt(spanSlider.value);
    document.getElementById('spanVal').innerText = spanFreq;
    const maxFreq = minFreq + spanFreq;
    
    // 軸ラベルの更新
    minLabel.innerText = `${Math.round(minFreq)} Hz`;
    maxLabel.innerText = `${Math.round(maxFreq)} Hz`;

    const binSize = audioCtx.sampleRate / analyser.fftSize;
    const points = [];

    ctx.beginPath(); ctx.strokeStyle = '#00ffcc'; ctx.lineWidth = 2.5;

    for (let i = 0; i < dataArray.length; i++) {
        const f = i * binSize;
        if (f < minFreq) continue;
        if (f > maxFreq) break;
        const x = ((f - minFreq) / spanFreq) * canvas.width;
        const y = canvas.height - Math.min((dataArray[i]/255)*vScale, 1.0)*canvas.height;
        if (points.length === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        points.push({ x, y, freq: f, val: dataArray[i] });
    }
    ctx.stroke();

    // 改良版ピーク検出ロジック
    let candidates = [];
    for (let i = 2; i < points.length - 2; i++) {
        // 山であることの判定（しきい値25以上）
        if (points[i].val > 25 && points[i].val > points[i-1].val && points[i].val > points[i+1].val) {
            candidates.push(points[i]);
        }
    }

    // 値の大きい順にソートし、近すぎるピーク（20ピクセル以内 or 10Hz以内）を除外
    let topPeaks = [];
    candidates.sort((a, b) => b.val - a.val);
    for (let cand of candidates) {
        if (topPeaks.length >= 5) break;
        let isTooClose = topPeaks.some(p => Math.abs(p.x - cand.x) < 40); // 40px以内は同一ピークとみなす
        if (!isTooClose) topPeaks.push(cand);
    }

    topPeaks.forEach(p => {
        ctx.fillStyle = '#ff4444'; ctx.beginPath(); ctx.arc(p.x, p.y, 5, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${12 * window.devicePixelRatio}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(p.freq)}Hz`, p.x, p.y - 15);
    });
}

function drawOscilloscope() {
    timeMs = parseInt(timeSlider.value);
    document.getElementById('timeVal').innerText = timeMs;
    
    // サンプリングレートに基づき、指定msに必要なサンプル数を計算
    const samplesToShow = Math.floor((timeMs / 1000) * audioCtx.sampleRate);
    
    ctx.beginPath(); ctx.strokeStyle = '#ff00ff'; ctx.lineWidth = 3;
    const sliceWidth = canvas.width / samplesToShow;
    let x = 0;
    
    // dataArrayの先頭から必要なサンプル分だけ描画
    for (let i = 0; i < samplesToShow; i++) {
        const v = (dataArray[i] - 128) / 128.0;
        const y = (canvas.height / 2) - (v * vScale * canvas.height / 2);
        if (i === 0) ctx.moveTo(x, y); else ctx.lineTo(x, y);
        x += sliceWidth;
    }
    ctx.stroke();
    ctx.setLineDash([5, 5]); ctx.strokeStyle = '#444';
    ctx.beginPath(); ctx.moveTo(0, canvas.height/2); ctx.lineTo(canvas.width, canvas.height/2); ctx.stroke();
    ctx.setLineDash([]);
}

modeBtn.onclick = () => {
    isOscilloscope = !isOscilloscope;
    document.getElementById('spectrumSliderBox').style.display = isOscilloscope ? "none" : "flex";
    document.getElementById('oscilloSliderBox').style.display = isOscilloscope ? "flex" : "none";
    minLabel.style.display = maxLabel.style.display = isOscilloscope ? "none" : "block";
    modeLabel.innerText = isOscilloscope ? "波形表示 (Time Domain)" : "周波数表示 (FFT)";
    modeLabel.style.borderColor = isOscilloscope ? "#ff00ff" : "#00ffcc";
};

toggleBtn.onclick = async () => {
    if (!audioCtx) { await init(); toggleBtn.innerText = "一時停止"; toggleBtn.classList.add('active'); }
    else if (audioCtx.state === 'running') { await audioCtx.suspend(); toggleBtn.innerText = "測定再開"; toggleBtn.classList.remove('active'); }
    else { await audioCtx.resume(); toggleBtn.innerText = "一時停止"; toggleBtn.classList.add('active'); }
};
</script>
</body>
</html>