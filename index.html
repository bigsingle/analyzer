<!DOCTYPE html>
<html lang="ja">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Resonance Analyzer - Swipe Edition</title>
    <style>
        :root { --accent: #00ffcc; }
        body { background: #1a1a1a; color: #fff; font-family: sans-serif; margin: 0; display: flex; flex-direction: column; align-items: center; overflow: hidden; touch-action: none; }
        .header { margin: 10px; text-align: center; }
        #freqRangeLabel { color: var(--accent); font-weight: bold; font-size: 1.2rem; }
        
        canvas { 
            width: 95vw; height: 50vh; background: #000; 
            border: 2px solid #333; border-radius: 8px; cursor: grab;
            touch-action: none; /* ブラウザのデフォルトスワイプを無効化 */
        }
        canvas:active { cursor: grabbing; }

        .controls { width: 90%; background: #2a2a2a; padding: 15px; border-radius: 12px; margin-top: 10px; display: grid; grid-template-columns: 1fr 2fr; gap: 15px; align-items: center; }
        button { padding: 15px; font-size: 1rem; font-weight: bold; background: var(--accent); border: none; border-radius: 8px; }
        .slider-box { display: flex; flex-direction: column; gap: 5px; }
        .help-text { font-size: 0.8rem; color: #aaa; text-align: center; margin-top: 5px; }
    </style>
</head>
<body>

    <div class="header">
        <div id="freqRangeLabel">0 Hz - 5000 Hz</div>
        <div class="help-text">グラフを左右にスワイプして移動</div>
    </div>

    <canvas id="visualizer"></canvas>

    <div class="controls">
        <button id="toggleBtn">計測開始</button>
        <div class="slider-box">
            <span style="font-size:0.8rem;">表示幅（スパン）: <span id="spanVal">5000</span>Hz</span>
            <input type="range" id="spanSlider" min="100" max="10000" step="100" value="5000">
        </div>
    </div>

<script>
let audioCtx, analyser, dataArray, animationId;
let minFreq = 0; // 表示の開始周波数
let spanFreq = 5000; // 表示する幅

const canvas = document.getElementById('visualizer');
const ctx = canvas.getContext('2d');
const toggleBtn = document.getElementById('toggleBtn');
const spanSlider = document.getElementById('spanSlider');
const freqLabel = document.getElementById('freqRangeLabel');

// キャンバスサイズ設定
function resize() {
    canvas.width = canvas.clientWidth * window.devicePixelRatio;
    canvas.height = canvas.clientHeight * window.devicePixelRatio;
}
window.addEventListener('resize', resize);
resize();

// --- スワイプ（パン）機能の実装 ---
let isDragging = false;
let startX = 0;
let startMinFreq = 0;

canvas.addEventListener('pointerdown', (e) => {
    isDragging = true;
    startX = e.clientX;
    startMinFreq = minFreq;
});

window.addEventListener('pointermove', (e) => {
    if (!isDragging || !audioCtx) return;
    
    const deltaX = e.clientX - startX;
    // 1ピクセルあたりの周波数移動量を計算
    const freqPerPixel = spanFreq / (canvas.clientWidth);
    minFreq = startMinFreq - (deltaX * freqPerPixel);

    // 範囲制限 (0Hz以下には行かない)
    if (minFreq < 0) minFreq = 0;
    const maxLimit = (audioCtx.sampleRate / 2) - spanFreq;
    if (minFreq > maxLimit) minFreq = maxLimit;
});

window.addEventListener('pointerup', () => isDragging = false);

// --- 音声処理と描画 ---
async function init() {
    audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
    const source = audioCtx.createMediaStreamSource(stream);
    analyser = audioCtx.createAnalyser();
    analyser.fftSize = 8192;
    source.connect(analyser);
    dataArray = new Uint8Array(analyser.frequencyBinCount);
    draw();
}

function draw() {
    animationId = requestAnimationFrame(draw);
    analyser.getByteFrequencyData(dataArray);

    spanFreq = parseInt(spanSlider.value);
    document.getElementById('spanVal').innerText = spanFreq;
    const maxFreq = minFreq + spanFreq;
    freqLabel.innerText = `${Math.round(minFreq)} Hz - ${Math.round(maxFreq)} Hz`;

    ctx.fillStyle = '#000';
    ctx.fillRect(0, 0, canvas.width, canvas.height);

    const binSize = audioCtx.sampleRate / analyser.fftSize;
    const points = [];

    ctx.beginPath();
    ctx.strokeStyle = '#00ffcc';
    ctx.lineWidth = 3;

    for (let i = 0; i < dataArray.length; i++) {
        const f = i * binSize;
        if (f < minFreq) continue;
        if (f > maxFreq) break;

        const x = ((f - minFreq) / spanFreq) * canvas.width;
        const y = canvas.height - (dataArray[i] / 255) * canvas.height;

        if (points.length === 0) ctx.moveTo(x, y);
        else ctx.lineTo(x, y);
        points.push({ x, y, freq: f, val: dataArray[i] });
    }
    ctx.stroke();

    // ピーク検出（上位5つ）
    let localPeaks = [];
    for (let i = 2; i < points.length - 2; i++) {
        if (points[i].val > 40 && 
            points[i].val >= points[i-1].val && points[i].val >= points[i+1].val) {
            localPeaks.push(points[i]);
        }
    }
    const topPeaks = localPeaks.sort((a, b) => b.val - a.val).slice(0, 5);

    topPeaks.forEach(p => {
        ctx.fillStyle = '#ff4444';
        ctx.beginPath(); ctx.arc(p.x, p.y, 6, 0, Math.PI*2); ctx.fill();
        ctx.fillStyle = '#fff';
        ctx.font = `bold ${14 * window.devicePixelRatio}px sans-serif`;
        ctx.textAlign = 'center';
        ctx.fillText(`${Math.round(p.freq)}Hz`, p.x, p.y - 20);
    });
}

toggleBtn.onclick = async () => {
    if (!audioCtx) await init();
    else if (audioCtx.state === 'running') await audioCtx.suspend();
    else await audioCtx.resume();
    toggleBtn.innerText = (audioCtx && audioCtx.state === 'running') ? "一時停止" : "計測再開";
};
</script>
</body>
</html>